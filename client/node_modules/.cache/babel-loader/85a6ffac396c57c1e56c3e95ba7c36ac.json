{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useCallback, useContext, useMemo, useRef, useState } from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  var stateRef = useRef();\n  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  var state = stateRef.current;\n  var _a = useState(0),\n    _tick = _a[0],\n    setTick = _a[1];\n  state.forceUpdate = function () {\n    setTick(function (tick) {\n      return tick + 1;\n    });\n  };\n  return state;\n}\nvar InternalState = function () {\n  function InternalState(client, query, previous) {\n    this.client = client;\n    this.query = query;\n    this.ssrDisabledResult = maybeDeepFreeze({\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    });\n    this.skipStandbyResult = maybeDeepFreeze({\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    });\n    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n    verifyDocumentType(query, DocumentType.Query);\n    var previousResult = previous && previous.result;\n    var previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n  InternalState.prototype.forceUpdate = function () {\n    __DEV__ && invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  };\n  InternalState.prototype.executeQuery = function (options) {\n    var _this = this;\n    var _a;\n    if (options.query) {\n      Object.assign(this, {\n        query: options.query\n      });\n    }\n    this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\n    this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n    return new Promise(function (resolve) {\n      var result;\n      concast.subscribe({\n        next: function next(value) {\n          result = value;\n        },\n        error: function error() {\n          resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n        },\n        complete: function complete() {\n          resolve(_this.toQueryResult(result));\n        }\n      });\n    });\n  };\n  InternalState.prototype.useQuery = function (options) {\n    var _this = this;\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n    this.useOptions(options);\n    var obsQuery = this.useObservableQuery();\n    var result = useSyncExternalStore(useCallback(function () {\n      if (_this.renderPromises) {\n        return function () {};\n      }\n      var onNext = function onNext() {\n        var previousResult = _this.result;\n        var result = obsQuery.getCurrentResult();\n        if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n          return;\n        }\n        _this.setResult(result);\n      };\n      var onError = function onError(error) {\n        var last = obsQuery[\"last\"];\n        subscription.unsubscribe();\n        try {\n          obsQuery.resetLastResults();\n          subscription = obsQuery.subscribe(onNext, onError);\n        } finally {\n          obsQuery[\"last\"] = last;\n        }\n        if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n          throw error;\n        }\n        var previousResult = _this.result;\n        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n          _this.setResult({\n            data: previousResult && previousResult.data,\n            error: error,\n            loading: false,\n            networkStatus: NetworkStatus.error\n          });\n        }\n      };\n      var subscription = obsQuery.subscribe(onNext, onError);\n      return function () {\n        return setTimeout(function () {\n          return subscription.unsubscribe();\n        });\n      };\n    }, [obsQuery, this.renderPromises, this.client.disableNetworkFetches]), function () {\n      return _this.getCurrentResult();\n    }, function () {\n      return _this.getCurrentResult();\n    });\n    this.unsafeHandlePartialRefetch(result);\n    return this.toQueryResult(result);\n  };\n  InternalState.prototype.useOptions = function (options) {\n    var _a;\n    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var currentWatchQueryOptions = this.watchQueryOptions;\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n      if (currentWatchQueryOptions && this.observable) {\n        this.observable.reobserve(this.getObsQueryOptions());\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n      }\n    }\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {\n      this.result = this.ssrDisabledResult;\n    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === 'standby') {\n      this.result = this.skipStandbyResult;\n    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n      this.result = void 0;\n    }\n  };\n  InternalState.prototype.getObsQueryOptions = function () {\n    var toMerge = [];\n    var globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n    toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n  };\n  InternalState.prototype.createWatchQueryOptions = function (_a) {\n    var _b;\n    if (_a === void 0) {\n      _a = {};\n    }\n    var skip = _a.skip,\n      ssr = _a.ssr,\n      onCompleted = _a.onCompleted,\n      onError = _a.onError,\n      defaultOptions = _a.defaultOptions,\n      otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    var watchQueryOptions = Object.assign(otherOptions, {\n      query: this.query\n    });\n    if (this.renderPromises && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n    if (skip) {\n      var _c = watchQueryOptions.fetchPolicy,\n        fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c,\n        _d = watchQueryOptions.initialFetchPolicy,\n        initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy: initialFetchPolicy,\n        fetchPolicy: 'standby'\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();\n    }\n    return watchQueryOptions;\n  };\n  InternalState.prototype.getDefaultFetchPolicy = function () {\n    var _a, _b;\n    return ((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"cache-first\";\n  };\n  InternalState.prototype.onCompleted = function (data) {};\n  InternalState.prototype.onError = function (error) {};\n  InternalState.prototype.useObservableQuery = function () {\n    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(this.getObsQueryOptions());\n    this.obsQueryFields = useMemo(function () {\n      return {\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n      };\n    }, [obsQuery]);\n    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n      if (obsQuery.getCurrentResult().loading) {\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n    return obsQuery;\n  };\n  InternalState.prototype.setResult = function (nextResult) {\n    var previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  };\n  InternalState.prototype.handleErrorOrCompleted = function (result) {\n    var _this = this;\n    if (!result.loading) {\n      var error_1 = this.toApolloError(result);\n      Promise.resolve().then(function () {\n        if (error_1) {\n          _this.onError(error_1);\n        } else if (result.data) {\n          _this.onCompleted(result.data);\n        }\n      }).catch(function (error) {\n        __DEV__ && invariant.warn(error);\n      });\n    }\n  };\n  InternalState.prototype.toApolloError = function (result) {\n    return isNonEmptyArray(result.errors) ? new ApolloError({\n      graphQLErrors: result.errors\n    }) : result.error;\n  };\n  InternalState.prototype.getCurrentResult = function () {\n    if (!this.result) {\n      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n    }\n    return this.result;\n  };\n  InternalState.prototype.toQueryResult = function (result) {\n    var queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n    var data = result.data,\n      partial = result.partial,\n      resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({\n      data: data\n    }, resultWithoutPartial), this.obsQueryFields), {\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData\n    }));\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      queryResult.error = new ApolloError({\n        graphQLErrors: result.errors\n      });\n    }\n    return queryResult;\n  };\n  InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== 'cache-only') {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      this.observable.refetch();\n    }\n  };\n  return InternalState;\n}();","map":null,"metadata":{},"sourceType":"module"}